# Frame v0.30 Language and Grammar Changes

## Overview

This document describes the language design decisions and grammar changes implemented in Frame v0.30, focusing on enhanced return statement handling, scope enforcement, and multi-entity architecture support.

## Grammar Changes

### 1. Return Statements as Regular Statements

**Enhancement**: `return` statements can now appear as regular statements within any block context.

#### Previous Grammar (v0.29)
```bnf
event_handler ::= identifier "(" parameter_list ")" "{" statement_list terminator "}"
terminator ::= "return" [expression] | transition_expr | parent_dispatch
```

#### New Grammar (v0.30)
```bnf
event_handler ::= identifier "(" parameter_list ")" "{" statement_list [terminator] "}"
statement ::= return_stmt | transition_stmt | assignment_stmt | if_stmt | ...
return_stmt ::= "return" [expression]
terminator ::= transition_expr | parent_dispatch
```

**Impact**:
- `return` can appear within `if/elif/else` blocks
- `return` can appear within loops and other control structures  
- Event handlers can have multiple `return` statements
- Automatic terminator insertion when no explicit terminator provided

#### Example Usage
```frame
processData(input: str): str {
    if input == "" {
        return "error: empty input"  // return as regular statement
    }
    
    if len(input) > 100 {
        return "error: too long"     // return in nested context
    }
    
    -> $Processing(input)            // transition terminator
}
```

### 2. Multi-Entity Scope Grammar

**Enhancement**: Formal grammar support for functions and systems as peer entities.

#### Module Structure Grammar
```bnf
module ::= [code_blocks] entity_list
entity_list ::= entity+
entity ::= function_decl | system_decl

function_decl ::= "fn" identifier "(" parameter_list ")" "{" statement_list "}"
system_decl ::= "system" identifier "{" system_blocks "}"
```

**Scope Resolution Rules**:
1. **Module Scope**: Functions accessible globally within module
2. **System Scope**: Actions/operations accessible only via `self.` within system
3. **Cross-Boundary Access**: Systems must use interface methods for external access

#### Example Multi-Entity File
```frame
fn main() {
    var processor = DataProcessor()  // ✓ Valid: system instantiation
    var result = process_text("test") // ✓ Valid: function call
    // var direct = processor.validateData_do("test") // ❌ Invalid: direct action access
}

fn process_text(text: str): str {
    return "processed: " + text
}

system DataProcessor {
    interface:
        process(data: str): str
        
    machine:
        $Ready {
            process(data: str): str {
                return validateData(data)  // ✓ Valid: action call within system
            }
        }
        
    actions:
        validateData(data: str): str {
            return "validated: " + data
        }
}
```

### 3. Enhanced Return Assignment Grammar

**Enhancement**: `return = expression` syntax for interface method returns.

#### Grammar Rule
```bnf
return_assignment ::= "return" "=" expression
statement ::= return_assignment | ...
```

#### Usage Context
- Only valid within event handlers that have interface method signatures
- Assigns value to interface method's return value
- Must be followed by transition or explicit `return` statement

#### Example
```frame
interface:
    calculate(x: int, y: int): int

machine:
    $Ready {
        calculate(x: int, y: int): int {
            var result = x + y
            return = result      // Interface return assignment  
            -> $Complete         // Transition after assignment
        }
    }
```

## Language Design Decisions

### 1. Scope Boundary Enforcement

**Decision**: Strict enforcement of scope boundaries between functions and systems.

**Rationale**:
- Maintains encapsulation in multi-entity architecture
- Prevents accidental access to private system internals
- Encourages proper interface design
- Aligns with object-oriented principles

**Implementation**:
- Standalone functions cannot call system actions directly
- System actions are private to their containing system
- Cross-system communication must use interface methods
- Transpiler generates semantic errors for scope violations

**Example Error Cases**:
```frame
fn main() {
    var utils = Utils()
    var result = add(5, 3)  // ❌ Error: 'add' action not accessible
}

system Utils {
    actions:
        add(x: int, y: int): int {
            return x + y
        }
}
```

**Correct Approach**:
```frame  
fn main() {
    var utils = Utils()
    var result = utils.calculate(5, 3)  // ✓ Valid: interface method
}

system Utils {
    interface:
        calculate(x: int, y: int): int
        
    machine:
        $Ready {
            calculate(x: int, y: int): int {
                return add(x, y)  // ✓ Valid: action call within system
            }
        }
        
    actions:
        add(x: int, y: int): int {
            return x + y
        }
}
```

### 2. Return Mechanism Differentiation

**Decision**: Different return mechanisms for event handlers vs actions/operations.

#### Event Handler Returns
- Use return stack mechanism: `self.return_stack[-1] = value`
- Support interruption by state transitions
- Enable complex control flow with multiple returns

#### Action/Operation Returns  
- Use direct Python returns: `return value`
- Guaranteed completion execution
- Simpler, more performant for internal operations

**Rationale**:
- Event handlers can be interrupted by state transitions
- Actions/operations have atomic execution semantics
- Maintains Frame's event-driven architecture model

### 3. Enum Deduplication Strategy

**Decision**: First-occurrence-wins deduplication for enum entries.

**Example**:
```frame
enum Days {
    SUNDAY    // ✓ Kept (first occurrence) 
    MONDAY
    TUESDAY
    SUNDAY    // ❌ Discarded (duplicate)
}
```

**Generated Python**:
```python
class System_Days(Enum):
    SUNDAY = 0   # Only first occurrence
    MONDAY = 1
    TUESDAY = 2
    # SUNDAY = 3  # Duplicate automatically removed
```

**Rationale**:
- Prevents Python enum conflicts
- Predictable and deterministic behavior  
- Follows common programming language conventions
- Maintains source order preference

## Semantic Rules

### 1. Automatic Terminator Insertion

**Rule**: Event handlers without explicit terminators automatically get `return` terminator.

**Example**:
```frame
processData(input: str) {
    print("Processing: " + input)
    // Automatic 'return' terminator inserted
}
```

**Generated**: 
```python  
def processData(self, input):
    print("Processing: " + input)
    return  # Auto-inserted
```

### 2. Return Statement Context Validation

**Rule**: Return statement behavior determined by containing scope.

#### In Event Handlers:
```frame
$State {
    handler(x: int): int {
        if x > 0 {
            return x * 2  // → self.return_stack[-1] = x * 2; return
        }
        return 0          // → self.return_stack[-1] = 0; return
    }
}
```

#### In Actions/Operations:
```frame
actions:
    calculate(x: int): int {
        if x > 0 {
            return x * 2  // → return x * 2
        }
        return 0          // → return 0
    }
```

### 3. State Transition Precedence

**Rule**: State transitions take precedence over return values.

**Example**:
```frame  
handler(): str {
    return = "processing"
    -> $NextState     // Transition occurs after return assignment
    return           // Required after transition
}
```

## Compatibility and Migration

### Backward Compatibility

**Maintained**:
- All existing v0.20 Frame syntax continues to work
- Existing event handler terminator patterns supported
- Legacy single-entity files fully compatible

**Enhanced**:
- Multi-entity files now properly supported
- Better error messages for scope violations  
- More flexible return statement placement

### Migration Guidelines

#### From Single-Entity to Multi-Entity
1. Add `fn main()` function wrapper
2. Convert utility actions to standalone functions or interface methods
3. Use proper system instantiation for object-oriented patterns

#### Updating Return Patterns
1. Replace terminator-only returns with statement returns where appropriate
2. Use `return = expr` for interface method returns
3. Take advantage of flexible return placement in control flow

## Implementation Notes

### Parser Changes
- Enhanced statement parsing to include return statements
- Improved terminator handling with automatic insertion
- Better error recovery for scope violations

### Code Generation Changes  
- Scope-aware return generation in Python visitor
- Proper `FrameCompartment` attribute handling
- Enhanced call resolution with context checking

### Symbol Table Enhancements
- Multi-pass symbol preservation
- Scope-aware symbol lookup
- Function vs system entity distinction

## Future Language Evolution

### Planned Enhancements
1. **Module System**: Import/export between Frame files
2. **Generics**: Parameterized types for systems and functions
3. **Pattern Matching**: Advanced control flow constructs  
4. **Async Support**: Asynchronous event handling patterns

### Considerations
- Maintain backward compatibility with v0.30
- Preserve Frame's event-driven architecture model
- Continue multi-entity architecture development
- Enhance type system capabilities

This language design provides a solid foundation for Frame v0.30's evolution while maintaining the simplicity and power that makes Frame effective for state machine programming.